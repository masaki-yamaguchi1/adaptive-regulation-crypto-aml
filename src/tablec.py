# -*- coding: utf-8 -*-
"""TableC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/174ZfD2IpvNHtWNUwrqL5wLMp7TJPqaxm
"""

import numpy as np

# -----------------------------
# Utilities
# -----------------------------
def clip01(x):
    return np.minimum(1.0, np.maximum(0.0, x))

# -----------------------------
# Core simulation
# -----------------------------
def simulate_metrics(
    Delta,
    sigma,
    update_rule="baseline",   # "baseline" or "smoothed"
    rho=0.3,                  # smoothing parameter
    J=10,
    T=1200,
    burn=300,
    theta=1.0,
    Dbar=0.5,
    lam=5.0,
    Mbar=1.0,
    tau=0.25,
    seed=0
):
    rng = np.random.default_rng(seed)

    s = rng.uniform(0, 1, size=J)
    M = np.full(J, Mbar / J)

    gaps = []

    for t in range(T):
        D = theta * s
        Dhat = D + rng.normal(0.0, sigma, size=J)

        # baseline discrete update
        s_target = clip01(
            s
            + Delta * (Dhat < Dbar)
            - Delta * (Dhat > Dbar)
        )

        # smoothed update
        if update_rule == "smoothed":
            s = clip01((1 - rho) * s + rho * s_target)
        else:
            s = s_target

        # illicit fund relocation
        w = np.exp(-lam * D)
        M = Mbar * w / w.sum()

        gaps.append(D.max() - D.min())

    gaps = np.array(gaps[burn:])

    lockin_index = gaps.mean()
    severe_prob = np.mean(gaps > tau)

    return lockin_index, severe_prob

# -----------------------------
# Representative points
# -----------------------------
points = {
    "Stable (0.02,0.02)": (0.02, 0.02),
    "Multiplicity (0.055,0.10)": (0.055, 0.10),
    "Severe (0.07,0.15)": (0.07, 0.15),
}

# -----------------------------
# Monte Carlo
# -----------------------------
R = 50
tau = 0.25

results = {}

for name, (Delta, sigma) in points.items():
    out = {}
    for rule in ["baseline", "smoothed"]:
        vals_L = []
        vals_P = []
        for r in range(R):
            L, P = simulate_metrics(
                Delta=Delta,
                sigma=sigma,
                update_rule=rule,
                tau=tau,
                seed=1000 + r
            )
            vals_L.append(L)
            vals_P.append(P)

        out[rule] = {
            "L_mean": np.mean(vals_L),
            "L_se": np.std(vals_L, ddof=1) / np.sqrt(R),
            "P_mean": np.mean(vals_P),
            "P_se": np.std(vals_P, ddof=1) / np.sqrt(R),
        }
    results[name] = out

# -----------------------------
# Print table-ready output
# -----------------------------
print("Appendix Table C: Robustness to the regulatory update rule\n")
for name, res in results.items():
    print(name)
    for rule in ["baseline", "smoothed"]:
        r = res[rule]
        print(
            f"  {rule:9s} | "
            f"Lock-in = {r['L_mean']:.3f} ({r['L_se']:.3f}) | "
            f"Pr(severe) = {r['P_mean']:.3f} ({r['P_se']:.3f})"
        )
    print()