# -*- coding: utf-8 -*-
"""Figure2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/103Znh9s5QogXPtiEol7B9pV_GJYa2alk
"""

import numpy as np
import matplotlib.pyplot as plt

# ---------- Core simulation ----------

def clip01(x):
    return np.minimum(1.0, np.maximum(0.0, x))

def simulate_once(J, T, burn, theta, Dbar, Delta, sigma, lam, Mbar, seed):
    rng = np.random.default_rng(seed)
    s = rng.uniform(0, 1, size=J)
    gaps = []

    for t in range(T):
        D = theta * s
        Dhat = D + rng.normal(0.0, sigma, size=J)
        s = clip01(s + Delta * (Dhat < Dbar) - Delta * (Dhat > Dbar))

        if t >= burn:
            gaps.append(D.max() - D.min())

    return np.mean(gaps)


# ---------- Figure 2 data ----------

def figure2_data(
    deltas, sigmas,
    J=12, T=2000, burn=500,
    theta=1.0, Dbar=0.5,
    lam=10.0, Mbar=1.0,
    runs=40,
    alpha=0.2
):
    tau = alpha * theta
    std_map = np.zeros((len(sigmas), len(deltas)))
    prob_map = np.zeros_like(std_map)

    for i, sigma in enumerate(sigmas):
        for j, Delta in enumerate(deltas):
            vals = []
            for r in range(runs):
                gbar = simulate_once(
                    J, T, burn,
                    theta, Dbar, Delta, sigma, lam, Mbar,
                    seed=10_000*i + 100*j + r
                )
                vals.append(gbar)

            vals = np.array(vals)
            std_map[i, j] = vals.std()
            prob_map[i, j] = np.mean(vals > tau)

    return std_map, prob_map


# ---------- Run & plot ----------

deltas = np.linspace(0.005, 0.08, 20)
sigmas = np.linspace(0.0, 0.20, 20)

std_map, prob_map = figure2_data(deltas, sigmas)

fig, axes = plt.subplots(1, 2, figsize=(11, 4.5))

# Panel A: Regime multiplicity
im0 = axes[0].imshow(
    std_map,
    origin="lower",
    aspect="auto",
    cmap="gray_r",   # high = dark
    extent=[deltas.min(), deltas.max(), sigmas.min(), sigmas.max()]
)
axes[0].set_title("Panel A: Regime multiplicity")
axes[0].set_xlabel("Adjustment step Δ")
axes[0].set_ylabel("Observation noise σ")
plt.colorbar(im0, ax=axes[0], fraction=0.046)

# Panel B: Probability of severe lock-in
im1 = axes[1].imshow(
    prob_map,
    origin="lower",
    aspect="auto",
    cmap="gray_r",   # high = dark
    vmin=0, vmax=1,
    extent=[deltas.min(), deltas.max(), sigmas.min(), sigmas.max()]
)
axes[1].set_title("Panel B: Probability of severe lock-in")
axes[1].set_xlabel("Adjustment step Δ")
plt.colorbar(im1, ax=axes[1], fraction=0.046)

plt.tight_layout()
plt.savefig("Figure2_lockin_bw.png", dpi=300)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import PowerNorm

# ---------- Core simulation ----------

def clip01(x):
    return np.minimum(1.0, np.maximum(0.0, x))

def simulate_once(J, T, burn, theta, Dbar, Delta, sigma, lam, Mbar, seed):
    rng = np.random.default_rng(seed)
    s = rng.uniform(0, 1, size=J)
    gaps = []

    for t in range(T):
        D = theta * s
        Dhat = D + rng.normal(0.0, sigma, size=J)
        s = clip01(s + Delta * (Dhat < Dbar) - Delta * (Dhat > Dbar))

        if t >= burn:
            gaps.append(D.max() - D.min())

    return np.mean(gaps)


# ---------- Figure 2 data ----------

def figure2_data(
    deltas, sigmas,
    J=12, T=2000, burn=500,
    theta=1.0, Dbar=0.5,
    lam=10.0, Mbar=1.0,
    runs=40,
    alpha=0.2
):
    tau = alpha * theta
    std_map = np.zeros((len(sigmas), len(deltas)))
    prob_map = np.zeros_like(std_map)

    for i, sigma in enumerate(sigmas):
        for j, Delta in enumerate(deltas):
            vals = []
            for r in range(runs):
                gbar = simulate_once(
                    J, T, burn,
                    theta, Dbar, Delta, sigma, lam, Mbar,
                    seed=10_000*i + 100*j + r
                )
                vals.append(gbar)

            vals = np.array(vals)
            std_map[i, j] = vals.std()
            prob_map[i, j] = np.mean(vals > tau)

    return std_map, prob_map


# ---------- Run & plot ----------

deltas = np.linspace(0.005, 0.08, 20)
sigmas = np.linspace(0.0, 0.20, 20)

std_map, prob_map = figure2_data(deltas, sigmas)

fig, axes = plt.subplots(1, 2, figsize=(11, 4.5))

# ----- Panel A: Regime multiplicity -----
im0 = axes[0].imshow(
    std_map,
    origin="lower",
    aspect="auto",
    cmap="gray_r",   # high = dark
    extent=[deltas.min(), deltas.max(), sigmas.min(), sigmas.max()]
)
axes[0].set_title("Panel A: Regime multiplicity")
axes[0].set_xlabel("Adjustment step Δ")
axes[0].set_ylabel("Observation noise σ")
cbar0 = plt.colorbar(im0, ax=axes[0], fraction=0.046)
cbar0.set_label("Lock-in index (dispersion)")


# ----- Panel B: Probability of severe lock-in -----
# Nonlinear normalization to match Figure 3 contrast
norm = PowerNorm(gamma=0.5, vmin=0.0, vmax=1.0)

im1 = axes[1].imshow(
    prob_map,
    origin="lower",
    aspect="auto",
    cmap="gray_r",   # high = dark
    norm=norm,
    extent=[deltas.min(), deltas.max(), sigmas.min(), sigmas.max()]
)
axes[1].set_title("Panel B: Probability of severe lock-in")
axes[1].set_xlabel("Adjustment step Δ")

# τ annotation (optional but recommended)
axes[1].text(
    0.98, 0.02,
    r"$\tau=\alpha\theta$",
    transform=axes[1].transAxes,
    ha="right", va="bottom",
    fontsize=10
)

cbar1 = plt.colorbar(im1, ax=axes[1], fraction=0.046)
cbar1.set_label(r"Pr(severe lock-in)")

plt.tight_layout()
plt.savefig("Figure2_lockin_bw.png", dpi=300)
plt.show()