# -*- coding: utf-8 -*-
"""FigureC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ELfOQ8oOIL0cx9HyapmJO9XhvRlmJ-9M
"""

import numpy as np
import matplotlib.pyplot as plt

# -----------------------------
# Utility functions
# -----------------------------
def clip01(x):
    return np.minimum(1.0, np.maximum(0.0, x))

def simulate_lockin(
    J=10,
    T=1000,
    burn=200,
    theta=1.0,
    Dbar=0.5,
    Delta=0.02,
    sigma=0.05,
    lam=5.0,
    Mbar=1.0,
    seed=0
):
    rng = np.random.default_rng(seed)

    s = rng.uniform(0, 1, size=J)
    M = np.full(J, Mbar / J)

    gap_hist = []

    for t in range(T):
        D = theta * s
        Dhat = D + rng.normal(0.0, sigma, size=J)

        s = clip01(
            s
            + Delta * (Dhat < Dbar)
            - Delta * (Dhat > Dbar)
        )

        w = np.exp(-lam * D)
        M = Mbar * w / w.sum()

        gap = D.max() - D.min()
        gap_hist.append(gap)

    return np.mean(gap_hist[burn:])

# -----------------------------
# Parameter grid
# -----------------------------
Delta_grid = np.linspace(0.01, 0.08, 15)
sigma_grid = np.linspace(0.01, 0.15, 15)

def compute_heatmap(lam, reps=5):
    H = np.zeros((len(sigma_grid), len(Delta_grid)))

    for i, sigma in enumerate(sigma_grid):
        for j, Delta in enumerate(Delta_grid):
            vals = []
            for r in range(reps):
                val = simulate_lockin(
                    Delta=Delta,
                    sigma=sigma,
                    lam=lam,
                    seed=1000 + r
                )
                vals.append(val)
            H[i, j] = np.mean(vals)
    return H

# -----------------------------
# Compute sensitivity cases
# -----------------------------
H_low = compute_heatmap(lam=2.0)
H_high = compute_heatmap(lam=8.0)

# -----------------------------
# Plot Appendix Figure C (fixed colorbar)
# -----------------------------
fig, axes = plt.subplots(1, 2, figsize=(10, 4), sharey=True)

vmin = min(H_low.min(), H_high.min())
vmax = max(H_low.max(), H_high.max())

im0 = axes[0].imshow(
    H_low,
    origin="lower",
    aspect="auto",
    cmap="Greys",
    vmin=vmin,
    vmax=vmax
)
axes[0].set_title(r"Low mobility ($\lambda=2$)")
axes[0].set_xlabel(r"$\Delta$")
axes[0].set_ylabel(r"$\sigma$")
axes[0].set_xticks(range(len(Delta_grid)))
axes[0].set_xticklabels([f"{d:.2f}" for d in Delta_grid], rotation=45)
axes[0].set_yticks(range(len(sigma_grid)))
axes[0].set_yticklabels([f"{s:.2f}" for s in sigma_grid])

im1 = axes[1].imshow(
    H_high,
    origin="lower",
    aspect="auto",
    cmap="Greys",
    vmin=vmin,
    vmax=vmax
)
axes[1].set_title(r"High mobility ($\lambda=8$)")
axes[1].set_xlabel(r"$\Delta$")
axes[1].set_xticks(range(len(Delta_grid)))
axes[1].set_xticklabels([f"{d:.2f}" for d in Delta_grid], rotation=45)

# --- create a dedicated axis for the colorbar ---
cax = fig.add_axes([0.92, 0.15, 0.02, 0.7])  # [left, bottom, width, height]
cbar = fig.colorbar(im1, cax=cax)
cbar.set_label("Lock-in index")

plt.tight_layout(rect=[0, 0, 0.9, 1])
plt.savefig("Appendix_Figure_C.png", dpi=300)
plt.show()